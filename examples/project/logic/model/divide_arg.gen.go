// Code generated by 'micro gen' command.
// DO NOT EDIT!

package model

import (
	"database/sql"
	"time"

	"github.com/henrylee2cn/goutil/coarsetime"
	tp "github.com/henrylee2cn/teleport"
	"github.com/xiaoenai/tp-micro/model/mysql"
	"github.com/xiaoenai/tp-micro/model/sqlx"
)

// DivideArg divide api arg
type DivideArg struct {
	Id int64 `json:"id"`
	// dividend
	A float64 `json:"a"`
	// divisor
	B         float64 `json:"b" param:"<range: 0.01:100000>"`
	CreatedAt int64   `json:"created_at"`
	UpdatedAt int64   `json:"updated_at"`
}

// TableName implements 'github.com/xiaoenai/tp-micro/model'.Cacheable
func (*DivideArg) TableName() string {
	return "divide_arg"
}

var divideArgDB, _ = dbHandler.RegCacheableDB(new(DivideArg), time.Hour*24, ``)

// GetDivideArgDB returns the DivideArg DB handler.
func GetDivideArgDB() *mysql.CacheableDB {
	return divideArgDB
}

// InsertDivideArg insert a DivideArg data into database.
// NOTE:
//  Without cache layer.
func InsertDivideArg(_d *DivideArg, tx ...*sqlx.Tx) (int64, error) {
	_d.UpdatedAt = coarsetime.FloorTimeNow().Unix()
	if _d.CreatedAt == 0 {
		_d.CreatedAt = _d.UpdatedAt
	}
	err := divideArgDB.Callback(func(tx sqlx.DbOrTx) error {
		var query string
		if _d.Id > 0 {
			query = "INSERT INTO `divide_arg` (id,`a`,`b`,`created_at`,`updated_at`)VALUES(:id,:a,:b,:created_at,:updated_at);"
		} else {
			query = "INSERT INTO `divide_arg` (`a`,`b`,`created_at`,`updated_at`)VALUES(:a,:b,:created_at,:updated_at);"
		}
		r, err := tx.NamedExec(query, _d)
		if err != nil {
			return err
		}
		id, err := r.LastInsertId()
		if err != nil {
			return err
		}
		_d.Id = id
		return nil
	}, tx...)
	return _d.Id, err
}

// UpdateDivideArgByPrimary update the DivideArg data in database by primary key.
// NOTE:
//  With cache layer;
//  _updateFields' members must be snake format;
//  Automatic update updated_at field;
//  Don't update the primary key and the created_at key;
//  Update all fields except the primary key and the created_at key if _updateFields is empty.
func UpdateDivideArgByPrimary(_d *DivideArg, _updateFields []string, tx ...*sqlx.Tx) error {
	_d.UpdatedAt = coarsetime.FloorTimeNow().Unix()
	err := divideArgDB.Callback(func(tx sqlx.DbOrTx) error {
		query := "UPDATE `divide_arg` SET "
		if len(_updateFields) == 0 {
			query += "`a`=:a,`b`=:b,`updated_at`=:updated_at WHERE id=:id LIMIT 1;"
		} else {
			for _, s := range _updateFields {
				if s == "updated_at" || s == "id" || s == "created_at" {
					continue
				}
				query += "`" + s + "`=:" + s + ","
			}
			if query[len(query)-1] != ',' {
				return nil
			}
			query += "`updated_at`=:updated_at WHERE id=:id LIMIT 1;"
		}
		_, err := tx.NamedExec(query, _d)
		return err
	}, tx...)
	if err != nil {
		return err
	}
	err = divideArgDB.DeleteCache(_d)
	if err != nil {
		tp.Errorf("%s", err.Error())
	}
	return nil
}

// UpsertDivideArg insert or update the DivideArg data by primary key.
// NOTE:
//  With cache layer;
//  Insert data if the primary key is specified;
//  Update data based on _updateFields if no primary key is specified;
//  _updateFields' members must be snake format;
//  Automatic update updated_at field;
//  Don't update the primary key and the created_at key;
//  Update all fields except the primary key and the created_at key if _updateFields is empty.
func UpsertDivideArg(_d *DivideArg, _updateFields []string, tx ...*sqlx.Tx) (int64, error) {
	if _d.Id <= 0 {
		return InsertDivideArg(_d, tx...)
	}
	if _d.UpdatedAt == 0 {
		_d.UpdatedAt = coarsetime.FloorTimeNow().Unix()
	}
	if _d.CreatedAt == 0 {
		_d.CreatedAt = _d.UpdatedAt
	}
	err := divideArgDB.Callback(func(tx sqlx.DbOrTx) error {
		query := "INSERT INTO `divide_arg` (id,`a`,`b`,`created_at`,`updated_at`)VALUES(:id,:a,:b,:created_at,:updated_at)" +
			" ON DUPLICATE KEY UPDATE "
		if len(_updateFields) == 0 {
			query += "`a`=VALUES(`a`),`b`=VALUES(`b`),`updated_at`=VALUES(`updated_at`);"
		} else {
			for _, s := range _updateFields {
				if s == "updated_at" || s == "id" || s == "created_at" {
					continue
				}
				query += "`" + s + "`=VALUES(`" + s + "`),"
			}
			if query[len(query)-1] != ',' {
				return nil
			}
			query += "`updated_at`=VALUES(`updated_at`);"
		}
		_, err := tx.NamedExec(query, _d)
		return err
	}, tx...)
	if err != nil {
		return 0, err
	}
	err = divideArgDB.DeleteCache(_d)
	if err != nil {
		tp.Errorf("%s", err.Error())
	}
	return _d.Id, nil
}

// DeleteDivideArgByPrimary delete a DivideArg data in database by primary key.
// NOTE:
//  With cache layer.
func DeleteDivideArgByPrimary(id int64, tx ...*sqlx.Tx) error {
	err := divideArgDB.Callback(func(tx sqlx.DbOrTx) error {
		_, err := tx.Exec("DELETE FROM `divide_arg` WHERE id=?;", id)
		return err
	}, tx...)
	if err != nil {
		return err
	}
	err = divideArgDB.PutCache(&DivideArg{
		Id: id,
	})
	if err != nil {
		tp.Errorf("%s", err.Error())
	}
	return nil
}

// GetDivideArgByPrimary query a DivideArg data from database by primary key.
// NOTE:
//  With cache layer;
//  If @return bool=false error=nil, means the data is not exist.
func GetDivideArgByPrimary(id int64) (*DivideArg, bool, error) {
	var _d = &DivideArg{
		Id: id,
	}
	err := divideArgDB.CacheGet(_d)
	switch err {
	case nil:
		if _d.CreatedAt == 0 {
			return nil, false, nil
		}
		return _d, true, nil
	case sql.ErrNoRows:
		err2 := divideArgDB.PutCache(_d)
		if err2 != nil {
			tp.Errorf("%s", err2.Error())
		}
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// BindDivideArgByFields query the DivideArg data from database by field keys, and bind it to _d.
// NOTE:
//  With cache layer;
//  _fields' members should be snake format;
//  Query by the primary key field if fields is empty;
//  If @return bool=false error=nil, means the data is not exist.
func BindDivideArgByFields(_d *DivideArg, _fields ...string) (bool, error) {
	err := divideArgDB.CacheGet(_d, _fields...)
	switch err {
	case nil:
		if _d.CreatedAt == 0 {
			return false, nil
		}
		return true, nil
	case sql.ErrNoRows:
		err2 := divideArgDB.PutCache(_d)
		if err2 != nil {
			tp.Errorf("%s", err2.Error())
		}
		return false, nil
	default:
		return false, err
	}
}

// BindDivideArgByWhere query the DivideArg data from database by WHERE condition(whereNamedCond), and bind it to _d.
// NOTE:
//  With cache layer;
//  If @return bool=false error=nil, means the data is not exist;
//  whereNamedCond e.g. 'id=:id AND created_at>1520000000'.
func BindDivideArgByWhere(_d *DivideArg, whereNamedCond string) (bool, error) {
	err := divideArgDB.CacheGetByWhere(_d, whereNamedCond)
	switch err {
	case nil:
		if _d.CreatedAt == 0 {
			return false, nil
		}
		return true, nil
	case sql.ErrNoRows:
		err2 := divideArgDB.PutCache(_d)
		if err2 != nil {
			tp.Errorf("%s", err2.Error())
		}
		return false, nil
	default:
		return false, err
	}
}

// GetDivideArgByWhere query a DivideArg data from database by WHERE condition.
// NOTE:
//  Without cache layer;
//  If @return bool=false error=nil, means the data is not exist.
func GetDivideArgByWhere(whereCond string, arg ...interface{}) (*DivideArg, bool, error) {
	var _d = new(DivideArg)
	err := divideArgDB.Get(_d, "SELECT id,`a`,`b`,`created_at`,`updated_at` FROM `divide_arg` WHERE "+whereCond+" LIMIT 1;", arg...)
	switch err {
	case nil:
		return _d, true, nil
	case sql.ErrNoRows:
		return nil, false, nil
	default:
		return nil, false, err
	}
}

// SelectDivideArgByWhere query some DivideArg data from database by WHERE condition.
// NOTE:
//  Without cache layer.
func SelectDivideArgByWhere(whereCond string, arg ...interface{}) ([]*DivideArg, error) {
	var objs = new([]*DivideArg)
	err := divideArgDB.Select(objs, "SELECT id,`a`,`b`,`created_at`,`updated_at` FROM `divide_arg` WHERE "+whereCond, arg...)
	return *objs, err
}

// CountDivideArgByWhere count DivideArg data number from database by WHERE condition.
// NOTE:
//  Without cache layer.
func CountDivideArgByWhere(whereCond string, arg ...interface{}) (int64, error) {
	var count int64
	err := divideArgDB.Get(&count, "SELECT count(1) FROM `divide_arg` WHERE "+whereCond, arg...)
	return count, err
}
